<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESPHome Pin Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

    <!-- CodeMirror -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/lib/codemirror.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/theme/material-darker.css">
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/lib/codemirror.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.13/mode/yaml/yaml.min.js"></script>
    <style>
        .pin-used {
            color: #198754;
            font-weight: bold;
        }

        .pin-commented {
            color: #6c757d;
            font-style: italic;
        }

        .pin-unused {
            color: #dc3545;
        }

        .analysis-result {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .CodeMirror {
            height: 400px;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
        }

        .csv-output {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.3;
            white-space: pre;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 0.75rem;
            height: 400px;
            overflow-y: auto;
        }

        .line-numbers {
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            padding: 0.75rem 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.3;
            color: #6c757d;
            user-select: none;
            white-space: pre;
            min-width: 50px;
            flex-shrink: 0;
        }

        .csv-container {
            display: flex;
            height: 400px;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
        }

        .csv-content {
            flex: 1;
            padding: 0.75rem;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.3;
            white-space: pre;
            background-color: #fff;
        }
    </style>
</head>

<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h1 class="mb-4">ESPHome Pin Analyzer</h1>
                <p class="text-muted">Paste your ESPHome YAML configuration to analyze pin usage</p>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="mb-3">
                    <label for="yamlInput" class="form-label">ESPHome YAML Configuration</label>
                    <div id="yamlInput"></div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="mb-3">
                    <label for="analysisOutput" class="form-label">Pin Analysis Results (CSV)</label>
                    <div class="csv-container">
                        <div class="line-numbers" id="lineNumbers"></div>
                        <div class="csv-content" id="analysisOutput">Pin analysis will appear here...</div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        class ESPHomePinAnalyzer {
            constructor() {
                this.pinUsage = new Map();
                this.commentedPins = new Map();
                this.lineNumberMap = new Map();
                this.allKnownPins = [
                    // ESP8266 pins
                    'D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'D10',
                    'A0', 'VCC', 'GND', 'RST', 'EN', 'TX', 'RX',
                    // GPIO pins (ESP8266 mapping)
                    'GPIO0', 'GPIO1', 'GPIO2', 'GPIO3', 'GPIO4', 'GPIO5',
                    'GPIO12', 'GPIO13', 'GPIO14', 'GPIO15', 'GPIO16',
                    // ESP32 pins (comprehensive list)
                    'GPIO6', 'GPIO7', 'GPIO8', 'GPIO9', 'GPIO10', 'GPIO11',
                    'GPIO17', 'GPIO18', 'GPIO19', 'GPIO20', 'GPIO21', 'GPIO22', 'GPIO23',
                    'GPIO24', 'GPIO25', 'GPIO26', 'GPIO27', 'GPIO28', 'GPIO29', 'GPIO30', 'GPIO31',
                    'GPIO32', 'GPIO33', 'GPIO34', 'GPIO35', 'GPIO36', 'GPIO37', 'GPIO38', 'GPIO39',
                    // Additional common pins
                    'IO0', 'IO1', 'IO2', 'IO3', 'IO4', 'IO5', 'IO12', 'IO13', 'IO14', 'IO15', 'IO16',
                    'MOSI', 'MISO', 'SCK', 'SDA', 'SCL', 'CLK'
                ];
            }

            analyzeYAML(yamlText) {
                this.pinUsage.clear();
                this.commentedPins.clear();
                this.lineNumberMap.clear();

                try {
                    // First, analyze commented pins from raw text
                    this.analyzeCommentedPins(yamlText);

                    // Second, analyze raw text to capture line numbers for all pins
                    this.analyzeRawText(yamlText);

                    // Try to parse YAML with ESPHome tag handling (preferred method for structured paths)
                    try {
                        const cleanedYaml = this.preprocessESPHomeYAML(yamlText);
                        const yamlDoc = jsyaml.load(cleanedYaml);
                        this.traverseObject(yamlDoc, '', '');
                    } catch (yamlError) {
                        console.warn('YAML parsing failed, using text-based analysis only:', yamlError);
                    }

                    return this.generateReport();
                } catch (error) {
                    return `Error analyzing YAML: ${error.message}`;
                }
            }

            preprocessESPHomeYAML(yamlText) {
                // Replace ESPHome-specific tags with placeholder values
                let cleaned = yamlText;

                // Handle !secret tags
                cleaned = cleaned.replace(/!secret\s+\w+/g, '"PLACEHOLDER_SECRET"');

                // Handle !include tags
                cleaned = cleaned.replace(/!include\s+[\w\/\.\-]+/g, '"PLACEHOLDER_INCLUDE"');

                // Handle !extend tags
                cleaned = cleaned.replace(/!extend\s+[\w\/\.\-]+/g, '"PLACEHOLDER_EXTEND"');

                // Handle !lambda tags (more complex, just replace with placeholder)
                cleaned = cleaned.replace(/!lambda\s*[\|\>]?[\s\S]*?(?=\n\S|\n$)/g, '"PLACEHOLDER_LAMBDA"');

                return cleaned;
            }

            analyzeRawText(yamlText) {
                this.lineNumberMap = new Map(); // Store pin -> line number mapping
                const lines = yamlText.split('\n');
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();

                    // Skip commented lines (already handled)
                    if (trimmedLine.startsWith('#')) return;

                    // Look for pin assignments in active lines and store line numbers
                    this.findPinsInLineWithNumber(line, `line ${index + 1}`, false, index + 1);
                });
            }

            findPinsInLineWithNumber(line, path, isCommented, lineNumber) {
                // Skip lines that contain common false positives
                const skipPatterns = [
                    /board:\s*d1_mini/i,
                    /address:\s*0x/i,
                    /data:\s*0x/i,
                    /version:/i,
                    /then:/i,
                    /friendly_name:/i,
                    /name:/i
                ];

                if (skipPatterns.some(pattern => pattern.test(line))) {
                    return;
                }

                // More precise pin detection patterns
                const pinPatterns = [
                    // Direct pin assignments with colon
                    /(?:pin|clk_pin|mosi_pin|miso_pin|cs_pin|sda|scl|data_pin|enable_pin|dc_pin|reset_pin|busy_pin):\s*([A-Z0-9]+)/gi,
                    // Pin with number property
                    /number:\s*([A-Z0-9]+)/gi,
                    // Standalone pin references in pin context
                    /pin:\s*([A-Z0-9]+)/gi
                ];

                pinPatterns.forEach(pattern => {
                    const matches = line.matchAll(pattern);
                    for (const match of matches) {
                        const pin = match[1] ? match[1].toUpperCase() : match[0].toUpperCase();
                        if (this.isValidPin(pin) && !this.shouldSkipPin(pin, line)) {
                            const normalizedPin = pin.toUpperCase();

                            // Store line number mapping for active pins
                            if (!isCommented) {
                                this.lineNumberMap.set(normalizedPin, lineNumber);
                            }

                            if (isCommented) {
                                if (!this.commentedPins.has(normalizedPin)) {
                                    this.commentedPins.set(normalizedPin, `${path} (${normalizedPin})`);
                                }
                            } else {
                                // Only add if we don't have a better structured path already
                                const currentPath = this.pinUsage.get(normalizedPin);
                                if (!currentPath) {
                                    this.pinUsage.set(normalizedPin, `${path} (${normalizedPin})`);
                                }
                            }
                        }
                    }
                });
            }

            analyzeCommentedPins(yamlText) {
                const lines = yamlText.split('\n');
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('#')) {
                        // Remove the # and analyze the commented line
                        const uncommentedLine = trimmedLine.substring(1).trim();
                        this.findPinsInLine(uncommentedLine, `line ${index + 1} (commented)`, true);
                    }
                });
            }

            traverseObject(obj, path, parentKey = '') {
                if (obj === null || obj === undefined) return;

                if (typeof obj === 'object') {
                    if (Array.isArray(obj)) {
                        obj.forEach((item, index) => {
                            // Try to find a name or id property for better context
                            let itemName = '';
                            if (item && typeof item === 'object') {
                                if (item.name) {
                                    itemName = ` (${item.name})`;
                                } else if (item.id) {
                                    itemName = ` (${item.id})`;
                                }
                            }
                            this.traverseObject(item, `${path}[${index}]${itemName}`, parentKey);
                        });
                    } else {
                        Object.keys(obj).forEach(key => {
                            const newPath = path ? `${path}.${key}` : key;

                            // Check if this key indicates a pin
                            if (this.isPinKey(key)) {
                                this.handlePinValue(obj[key], newPath, key);
                            } else {
                                this.traverseObject(obj[key], newPath, key);
                            }
                        });
                    }
                } else if (typeof obj === 'string') {
                    // Only check string values if they might be pins and we're in a pin context
                    if (parentKey && this.isPinKey(parentKey)) {
                        this.handlePinValue(obj, path, parentKey);
                    }
                }
            }

            isPinKey(key) {
                const pinKeys = [
                    'pin', 'clk_pin', 'mosi_pin', 'miso_pin', 'cs_pin',
                    'sda', 'scl', 'data_pin', 'enable_pin', 'dc_pin',
                    'reset_pin', 'busy_pin', 'cs', 'dc', 'reset',
                    'red', 'green', 'blue', 'white', 'warm_white', 'cold_white'
                ];
                return pinKeys.includes(key.toLowerCase());
            }

            handlePinValue(value, path, pinType = 'pin') {
                if (typeof value === 'string') {
                    const normalizedPin = value.toUpperCase();
                    if (this.isValidPin(normalizedPin)) {
                        // Only update if we don't have this pin yet, or if the new path is more detailed
                        const currentPath = this.pinUsage.get(normalizedPin);
                        if (!currentPath || currentPath.includes('line ')) {
                            this.pinUsage.set(normalizedPin, path);
                        }
                    }
                } else if (typeof value === 'object' && value !== null) {
                    if (value.number && this.isValidPin(value.number)) {
                        const normalizedPin = value.number.toString().toUpperCase();
                        const pinDetails = [];
                        if (value.inverted) pinDetails.push('inverted');
                        if (value.mode) pinDetails.push(value.mode);

                        const pinInfo = pinDetails.length > 0 ?
                            `${path} = ${normalizedPin} (${pinDetails.join(', ')})` :
                            path;

                        const currentPath = this.pinUsage.get(normalizedPin);
                        if (!currentPath || currentPath.includes('line ')) {
                            this.pinUsage.set(normalizedPin, pinInfo);
                        }
                    }
                    // Handle other pin object properties
                    Object.keys(value).forEach(key => {
                        if (key === 'number') {
                            // Already handled above
                        } else if (this.isValidPin(value[key])) {
                            const normalizedPin = value[key].toString().toUpperCase();
                            const currentPath = this.pinUsage.get(normalizedPin);
                            if (!currentPath || currentPath.includes('line ')) {
                                this.pinUsage.set(normalizedPin, `${path}.${key}`);
                            }
                        }
                    });
                } else if (typeof value === 'number') {
                    // Sometimes pins are just numbers
                    const pinStr = value.toString();
                    if (this.isValidPin(pinStr) || this.isValidPin(`GPIO${pinStr}`)) {
                        const normalizedPin = pinStr.toUpperCase();
                        const currentPath = this.pinUsage.get(normalizedPin);
                        if (!currentPath || currentPath.includes('line ')) {
                            this.pinUsage.set(normalizedPin, path);
                        }
                    }
                }
            }

            findPinsInLine(line, path, isCommented) {
                // Skip lines that contain common false positives
                const skipPatterns = [
                    /board:\s*d1_mini/i,
                    /address:\s*0x/i,
                    /data:\s*0x/i,
                    /version:/i,
                    /then:/i,
                    /friendly_name:/i,
                    /name:/i
                ];

                if (skipPatterns.some(pattern => pattern.test(line))) {
                    return;
                }

                // More precise pin detection patterns
                const pinPatterns = [
                    // Direct pin assignments with colon
                    /(?:pin|clk_pin|mosi_pin|miso_pin|cs_pin|sda|scl|data_pin|enable_pin|dc_pin|reset_pin|busy_pin):\s*([A-Z0-9]+)/gi,
                    // Pin with number property
                    /number:\s*([A-Z0-9]+)/gi,
                    // Standalone pin references in pin context
                    /pin:\s*([A-Z0-9]+)/gi
                ];

                pinPatterns.forEach(pattern => {
                    const matches = line.matchAll(pattern);
                    for (const match of matches) {
                        const pin = match[1] ? match[1].toUpperCase() : match[0].toUpperCase();
                        if (this.isValidPin(pin) && !this.shouldSkipPin(pin, line)) {
                            const normalizedPin = pin.toUpperCase();
                            if (isCommented) {
                                if (!this.commentedPins.has(normalizedPin)) {
                                    this.commentedPins.set(normalizedPin, `${path} (${normalizedPin})`);
                                }
                            } else {
                                // Only add if we don't have a better structured path already
                                const currentPath = this.pinUsage.get(normalizedPin);
                                if (!currentPath) {
                                    this.pinUsage.set(normalizedPin, `${path} (${normalizedPin})`);
                                }
                            }
                        }
                    }
                });
            }

            shouldSkipPin(pin, line) {
                // Skip common false positives
                const skipList = ['EN', 'ON', 'IN', 'UP', 'IF', 'OR', 'TO', 'BY', 'AT', 'AS', 'GO'];
                if (skipList.includes(pin.toUpperCase())) {
                    return true;
                }

                // Skip if it's part of a hex address or data
                if (/0x[0-9A-F]*/.test(line.toUpperCase())) {
                    return true;
                }

                return false;
            }

            isValidPin(pin) {
                if (!pin || typeof pin !== 'string') return false;
                const pinStr = pin.toString().toUpperCase();

                // Check against known pins
                if (this.allKnownPins.some(knownPin => knownPin.toUpperCase() === pinStr)) {
                    return true;
                }

                // Check patterns
                const patterns = [
                    /^D\d+$/,           // D0, D1, etc.
                    /^A\d+$/,           // A0, A1, etc.
                    /^GPIO\d+$/,        // GPIO0, GPIO1, etc.
                    /^IO\d+$/,          // IO0, IO1, etc.
                ];

                return patterns.some(pattern => pattern.test(pinStr));
            }

            generateReport() {
                let csvLines = [];

                // CSV Header
                csvLines.push("Pin;Path;ID;Friendly Name;Modes;Line Number");

                // Process active pins
                const sortedActive = Array.from(this.pinUsage.entries()).sort((a, b) => {
                    const pinA = a[0], pinB = b[0];
                    const getDOrder = (pin) => {
                        if (pin.startsWith('D')) return 1;
                        if (pin.startsWith('A')) return 2;
                        if (pin.startsWith('GPIO')) return 3;
                        return 4;
                    };
                    const orderA = getDOrder(pinA), orderB = getDOrder(pinB);
                    if (orderA !== orderB) return orderA - orderB;
                    return pinA.localeCompare(pinB);
                });

                sortedActive.forEach(([pin, path]) => {
                    const { componentPath, id, friendlyName, modes, lineNumber } = this.parsePathInfo(path, pin);
                    csvLines.push(`${pin};${componentPath};${id};${friendlyName};${modes};${lineNumber}`);
                });

                // Process commented pins
                const sortedCommented = Array.from(this.commentedPins.entries()).sort((a, b) => {
                    const pinA = a[0], pinB = b[0];
                    const getDOrder = (pin) => {
                        if (pin.startsWith('D')) return 1;
                        if (pin.startsWith('A')) return 2;
                        if (pin.startsWith('GPIO')) return 3;
                        return 4;
                    };
                    const orderA = getDOrder(pinA), orderB = getDOrder(pinB);
                    if (orderA !== orderB) return orderA - orderB;
                    return pinA.localeCompare(pinB);
                });

                sortedCommented.forEach(([pin, path]) => {
                    const { componentPath, id, friendlyName, modes, lineNumber } = this.parsePathInfo(path, pin);
                    csvLines.push(`#${pin};${componentPath};${id};${friendlyName};${modes};${lineNumber}`);
                });

                return csvLines.join('\n');
            }

            parsePathInfo(path, pin = null) {
                let componentPath = "";
                let id = "";
                let friendlyName = "";
                let modes = "";
                let lineNumber = "";

                // Handle different path formats
                if (path.includes('line ') && path.includes('(commented)')) {
                    // Commented pin format: "line 41 (commented) (D0)"
                    const lineMatch = path.match(/line\s+(\d+)/);
                    if (lineMatch) {
                        lineNumber = lineMatch[1];
                    }
                    componentPath = "commented";
                } else {
                    // Active pin formats
                    // Extract friendly name from parentheses (human readable names)
                    const friendlyNameMatches = path.match(/\(([^)]+)\)/g);
                    if (friendlyNameMatches) {
                        friendlyNameMatches.forEach(match => {
                            const content = match.replace(/[()]/g, '');
                            // Check if it's a friendly name (has spaces, quotes, or common words)
                            if ((content.includes(' ') || content.includes('"') ||
                                content.includes('LED') || content.includes('Sensor') ||
                                content.includes('Relais') || content.includes('Light')) &&
                                !content.includes('inverted') && !content.includes('INPUT_PULLUP')) {
                                friendlyName = `"${content.replace(/"/g, '')}"`;
                            }
                        });
                    }

                    // Extract modes (technical parameters)
                    const modeMatches = path.match(/=\s*[A-Z0-9]+\s*\(([^)]+)\)/);
                    if (modeMatches) {
                        modes = modeMatches[1];
                    } else {
                        // Look for modes in other parentheses
                        const allMatches = path.match(/\(([^)]+)\)/g);
                        if (allMatches) {
                            allMatches.forEach(match => {
                                const content = match.replace(/[()]/g, '');
                                if (content.includes('inverted') || content.includes('INPUT_PULLUP') ||
                                    content.includes('OUTPUT') || content.includes('pin')) {
                                    if (modes) modes += ', ';
                                    modes += content;
                                }
                            });
                        }
                    }

                    // Extract ID from path - look for component IDs
                    const allParentheses = path.match(/\(([^)]+)\)/g) || [];
                    allParentheses.forEach(match => {
                        const content = match.replace(/[()]/g, '');

                        // Check if it's a component ID (specific patterns)
                        if ((content.includes('_') ||
                            content.match(/^(led|sensor|relais|mcp|gpio|output|switch|binary_sensor)/i)) &&
                            !content.includes(' ') &&
                            !content.includes('"') &&
                            !content.includes('inverted') &&
                            !content.includes('INPUT_PULLUP') &&
                            !content.includes('OUTPUT') &&
                            !content.includes('LED') &&
                            !content.includes('Sensor') &&
                            !content.includes('Relais') &&
                            !content.includes('Light') &&
                            !content.includes('GPIO') &&
                            !content.includes('Temperature') &&
                            !content.includes('Humidity') &&
                            !content.includes('Signal') &&
                            content !== friendlyName.replace(/"/g, '')) {
                            id = content;
                        }
                    });

                    // Clean up component path - extract base path before parentheses
                    const basePathMatch = path.match(/^([^(=]+)/);
                    if (basePathMatch) {
                        componentPath = basePathMatch[1].trim();
                    } else {
                        componentPath = path.split('=')[0].trim();
                    }

                    // For active pins, get line number from our mapping
                    if (pin && this.lineNumberMap && this.lineNumberMap.has(pin)) {
                        lineNumber = this.lineNumberMap.get(pin).toString();
                    } else {
                        lineNumber = "";
                    }
                }

                return { componentPath, id, friendlyName, modes, lineNumber };
            }
        }

        // Initialize the analyzer
        const analyzer = new ESPHomePinAnalyzer();

        // Set up event listeners
        document.addEventListener('DOMContentLoaded', function () {
            const analysisOutput = document.getElementById('analysisOutput');
            const lineNumbers = document.getElementById('lineNumbers');

            // Initialize CodeMirror
            const editor = CodeMirror(document.getElementById('yamlInput'), {
                mode: 'yaml',
                theme: 'default',
                lineNumbers: true,
                lineWrapping: true,
                indentUnit: 2,
                tabSize: 2,
                placeholder: 'Paste your ESPHome YAML configuration here...',
                viewportMargin: Infinity
            });

            function updateLineNumbers(csvContent) {
                const lines = csvContent.split('\n');
                const lineNumbersText = lines.map((_, index) => (index + 1).toString().padStart(3, ' ')).join('\n');
                lineNumbers.textContent = lineNumbersText;
            }

            function performAnalysis() {
                const yamlContent = editor.getValue().trim();
                if (yamlContent) {
                    const analysis = analyzer.analyzeYAML(yamlContent);
                    analysisOutput.textContent = analysis;
                    updateLineNumbers(analysis);
                } else {
                    const placeholder = 'Pin;Path;ID;Friendly Name;Modes;Line Number\nPaste your ESPHome YAML configuration above to analyze pin usage.';
                    analysisOutput.textContent = placeholder;
                    updateLineNumbers(placeholder);
                }
            }

            // Analyze on input change (with debounce)
            let timeout;
            editor.on('change', function () {
                clearTimeout(timeout);
                timeout = setTimeout(performAnalysis, 500);
            });

            // Initial setup
            performAnalysis();
        });
    </script>
</body>

</html>
