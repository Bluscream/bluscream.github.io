<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESPHome Pin Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        .pin-used {
            color: #198754;
            font-weight: bold;
        }

        .pin-commented {
            color: #6c757d;
            font-style: italic;
        }

        .pin-unused {
            color: #dc3545;
        }

        .analysis-result {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
</head>

<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h1 class="mb-4">ESPHome Pin Analyzer</h1>
                <p class="text-muted">Paste your ESPHome YAML configuration to analyze pin usage</p>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="mb-3">
                    <label for="yamlInput" class="form-label">ESPHome YAML Configuration</label>
                    <textarea class="form-control" id="yamlInput" rows="15" placeholder="Paste your ESPHome YAML configuration here..." style="font-family: 'Courier New', monospace; font-size: 0.9em;"></textarea>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="mb-3">
                    <label for="analysisOutput" class="form-label">Pin Analysis Results</label>
                    <textarea class="form-control analysis-result" id="analysisOutput" rows="20" readonly placeholder="Pin analysis will appear here..."></textarea>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="alert alert-info">
                    <h6>Legend:</h6>
                    <ul class="mb-0">
                        <li><span class="pin-used">Green</span>: Active pin usage</li>
                        <li><span class="pin-commented">Gray/Italic</span>: Commented out pin usage</li>
                        <li><span class="pin-unused">Red</span>: Available/unused pins</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        class ESPHomePinAnalyzer {
            constructor() {
                this.pinUsage = new Map();
                this.commentedPins = new Map();
                this.allKnownPins = [
                    // ESP8266 pins
                    'D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8',
                    'A0', 'VCC', 'GND', 'RST', 'EN', 'TX', 'RX',
                    // GPIO pins
                    'GPIO0', 'GPIO1', 'GPIO2', 'GPIO3', 'GPIO4', 'GPIO5',
                    'GPIO12', 'GPIO13', 'GPIO14', 'GPIO15', 'GPIO16',
                    // ESP32 pins (common ones)
                    'GPIO18', 'GPIO19', 'GPIO21', 'GPIO22', 'GPIO23', 'GPIO25',
                    'GPIO26', 'GPIO27', 'GPIO32', 'GPIO33', 'GPIO34', 'GPIO35'
                ];
            }

            analyzeYAML(yamlText) {
                this.pinUsage.clear();
                this.commentedPins.clear();

                try {
                    // First, analyze commented pins from raw text
                    this.analyzeCommentedPins(yamlText);

                    // Then parse the active YAML
                    const yamlDoc = jsyaml.load(yamlText);
                    this.traverseObject(yamlDoc, '');

                    return this.generateReport();
                } catch (error) {
                    return `Error parsing YAML: ${error.message}`;
                }
            }

            analyzeCommentedPins(yamlText) {
                const lines = yamlText.split('\n');
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('#')) {
                        // Remove the # and analyze the commented line
                        const uncommentedLine = trimmedLine.substring(1).trim();
                        this.findPinsInLine(uncommentedLine, `line ${index + 1} (commented)`, true);
                    }
                });
            }

            traverseObject(obj, path) {
                if (obj === null || obj === undefined) return;

                if (typeof obj === 'object') {
                    if (Array.isArray(obj)) {
                        obj.forEach((item, index) => {
                            this.traverseObject(item, `${path}[${index}]`);
                        });
                    } else {
                        Object.keys(obj).forEach(key => {
                            const newPath = path ? `${path}.${key}` : key;

                            // Check if this key indicates a pin
                            if (this.isPinKey(key)) {
                                this.handlePinValue(obj[key], newPath);
                            } else {
                                this.traverseObject(obj[key], newPath);
                            }
                        });
                    }
                } else if (typeof obj === 'string') {
                    // Check if the string value might be a pin
                    this.findPinsInLine(obj, path, false);
                }
            }

            isPinKey(key) {
                const pinKeys = [
                    'pin', 'clk_pin', 'mosi_pin', 'miso_pin', 'cs_pin',
                    'sda', 'scl', 'data_pin', 'enable_pin', 'dc_pin',
                    'reset_pin', 'busy_pin', 'cs', 'dc', 'reset',
                    'red', 'green', 'blue', 'white', 'warm_white', 'cold_white'
                ];
                return pinKeys.includes(key.toLowerCase());
            }

            handlePinValue(value, path) {
                if (typeof value === 'string') {
                    if (this.isValidPin(value)) {
                        this.pinUsage.set(value, path);
                    }
                } else if (typeof value === 'object' && value !== null) {
                    if (value.number && this.isValidPin(value.number)) {
                        const pinInfo = `${value.number}${value.inverted ? ' (inverted)' : ''}${value.mode ? ` (${value.mode})` : ''}`;
                        this.pinUsage.set(value.number, `${path} = ${pinInfo}`);
                    }
                    // Handle other pin object properties
                    Object.keys(value).forEach(key => {
                        if (key === 'number' && this.isValidPin(value[key])) {
                            // Already handled above
                        } else if (this.isValidPin(value[key])) {
                            this.pinUsage.set(value[key], `${path}.${key}`);
                        }
                    });
                } else if (typeof value === 'number') {
                    // Sometimes pins are just numbers
                    const pinStr = value.toString();
                    if (this.isValidPin(pinStr) || this.isValidPin(`GPIO${pinStr}`)) {
                        this.pinUsage.set(pinStr, path);
                    }
                }
            }

            findPinsInLine(line, path, isCommented) {
                // Find pin patterns in text
                const pinPatterns = [
                    /pin:\s*([A-Z0-9]+)/gi,
                    /([A-Z]+\d+)/gi,
                    /(GPIO\d+)/gi,
                    /([A-Z]\d+)/gi
                ];

                pinPatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(line)) !== null) {
                        const pin = match[1] || match[0];
                        if (this.isValidPin(pin)) {
                            if (isCommented) {
                                this.commentedPins.set(pin, path);
                            } else if (!this.pinUsage.has(pin)) {
                                this.pinUsage.set(pin, path);
                            }
                        }
                    }
                });
            }

            isValidPin(pin) {
                if (!pin || typeof pin !== 'string') return false;
                const pinStr = pin.toString().toUpperCase();

                // Check against known pins
                if (this.allKnownPins.some(knownPin => knownPin.toUpperCase() === pinStr)) {
                    return true;
                }

                // Check patterns
                const patterns = [
                    /^D\d+$/,           // D0, D1, etc.
                    /^A\d+$/,           // A0, A1, etc.
                    /^GPIO\d+$/,        // GPIO0, GPIO1, etc.
                    /^IO\d+$/,          // IO0, IO1, etc.
                ];

                return patterns.some(pattern => pattern.test(pinStr));
            }

            generateReport() {
                let report = "=== ESPHome Pin Analysis Report ===\n\n";

                // Active pins
                report += "ðŸŸ¢ ACTIVE PINS:\n";
                report += "================\n";
                if (this.pinUsage.size === 0) {
                    report += "No active pins found.\n";
                } else {
                    const sortedActive = Array.from(this.pinUsage.entries()).sort();
                    sortedActive.forEach(([pin, path]) => {
                        report += `${pin.padEnd(8)} â†’ ${path}\n`;
                    });
                }

                report += "\n";

                // Commented pins
                report += "âšª COMMENTED/DISABLED PINS:\n";
                report += "===========================\n";
                if (this.commentedPins.size === 0) {
                    report += "No commented pins found.\n";
                } else {
                    const sortedCommented = Array.from(this.commentedPins.entries()).sort();
                    sortedCommented.forEach(([pin, path]) => {
                        report += `${pin.padEnd(8)} â†’ ${path}\n`;
                    });
                }

                report += "\n";

                // Available pins
                report += "ðŸ”´ AVAILABLE/UNUSED PINS:\n";
                report += "==========================\n";
                const usedPins = new Set([...this.pinUsage.keys(), ...this.commentedPins.keys()]);
                const availablePins = this.allKnownPins.filter(pin => !usedPins.has(pin));

                if (availablePins.length === 0) {
                    report += "All known pins are in use or commented.\n";
                } else {
                    availablePins.forEach(pin => {
                        report += `${pin}\n`;
                    });
                }

                report += "\n";

                // Summary
                report += "ðŸ“Š SUMMARY:\n";
                report += "============\n";
                report += `Active pins:     ${this.pinUsage.size}\n`;
                report += `Commented pins:  ${this.commentedPins.size}\n`;
                report += `Available pins:  ${availablePins.length}\n`;
                report += `Total known pins: ${this.allKnownPins.length}\n`;

                return report;
            }
        }

        // Initialize the analyzer
        const analyzer = new ESPHomePinAnalyzer();

        // Set up event listeners
        document.addEventListener('DOMContentLoaded', function () {
            const yamlInput = document.getElementById('yamlInput');
            const analysisOutput = document.getElementById('analysisOutput');

            function performAnalysis() {
                const yamlContent = yamlInput.value.trim();
                if (yamlContent) {
                    const analysis = analyzer.analyzeYAML(yamlContent);
                    analysisOutput.value = analysis;
                } else {
                    analysisOutput.value = 'Please paste your ESPHome YAML configuration above.';
                }
            }

            // Analyze on input change (with debounce)
            let timeout;
            yamlInput.addEventListener('input', function () {
                clearTimeout(timeout);
                timeout = setTimeout(performAnalysis, 500);
            });

            // Analyze on paste
            yamlInput.addEventListener('paste', function () {
                setTimeout(performAnalysis, 100);
            });
        });
    </script>
</body>

</html>
