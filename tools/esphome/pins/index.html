<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESPHome Pin Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        .pin-used {
            color: #198754;
            font-weight: bold;
        }

        .pin-commented {
            color: #6c757d;
            font-style: italic;
        }

        .pin-unused {
            color: #dc3545;
        }

        .analysis-result {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }
    </style>
</head>

<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h1 class="mb-4">ESPHome Pin Analyzer</h1>
                <p class="text-muted">Paste your ESPHome YAML configuration to analyze pin usage</p>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="mb-3">
                    <label for="yamlInput" class="form-label">ESPHome YAML Configuration</label>
                    <textarea class="form-control" id="yamlInput" rows="15" placeholder="Paste your ESPHome YAML configuration here..." style="font-family: 'Courier New', monospace; font-size: 0.9em;"></textarea>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="mb-3">
                    <label for="analysisOutput" class="form-label">Pin Analysis Results</label>
                    <textarea class="form-control analysis-result" id="analysisOutput" rows="20" readonly placeholder="Pin analysis will appear here..."></textarea>
                </div>
            </div>
        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        class ESPHomePinAnalyzer {
            constructor() {
                this.pinUsage = new Map();
                this.commentedPins = new Map();
                this.allKnownPins = [
                    // ESP8266 pins
                    'D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'D10',
                    'A0', 'VCC', 'GND', 'RST', 'EN', 'TX', 'RX',
                    // GPIO pins (ESP8266 mapping)
                    'GPIO0', 'GPIO1', 'GPIO2', 'GPIO3', 'GPIO4', 'GPIO5',
                    'GPIO12', 'GPIO13', 'GPIO14', 'GPIO15', 'GPIO16',
                    // ESP32 pins (comprehensive list)
                    'GPIO6', 'GPIO7', 'GPIO8', 'GPIO9', 'GPIO10', 'GPIO11',
                    'GPIO17', 'GPIO18', 'GPIO19', 'GPIO20', 'GPIO21', 'GPIO22', 'GPIO23',
                    'GPIO24', 'GPIO25', 'GPIO26', 'GPIO27', 'GPIO28', 'GPIO29', 'GPIO30', 'GPIO31',
                    'GPIO32', 'GPIO33', 'GPIO34', 'GPIO35', 'GPIO36', 'GPIO37', 'GPIO38', 'GPIO39',
                    // Additional common pins
                    'IO0', 'IO1', 'IO2', 'IO3', 'IO4', 'IO5', 'IO12', 'IO13', 'IO14', 'IO15', 'IO16',
                    'MOSI', 'MISO', 'SCK', 'SDA', 'SCL', 'CLK'
                ];
            }

            analyzeYAML(yamlText) {
                this.pinUsage.clear();
                this.commentedPins.clear();

                try {
                    // First, analyze commented pins from raw text
                    this.analyzeCommentedPins(yamlText);

                    // Analyze pins from raw text (fallback method)
                    this.analyzeRawText(yamlText);

                    // Try to parse YAML with ESPHome tag handling
                    try {
                        const cleanedYaml = this.preprocessESPHomeYAML(yamlText);
                        const yamlDoc = jsyaml.load(cleanedYaml);
                        this.traverseObject(yamlDoc, '', '');
                    } catch (yamlError) {
                        // If YAML parsing fails, we still have the raw text analysis
                        console.warn('YAML parsing failed, using text-based analysis only:', yamlError);
                    }

                    return this.generateReport();
                } catch (error) {
                    return `Error analyzing YAML: ${error.message}`;
                }
            }

            preprocessESPHomeYAML(yamlText) {
                // Replace ESPHome-specific tags with placeholder values
                let cleaned = yamlText;

                // Handle !secret tags
                cleaned = cleaned.replace(/!secret\s+\w+/g, '"PLACEHOLDER_SECRET"');

                // Handle !include tags
                cleaned = cleaned.replace(/!include\s+[\w\/\.\-]+/g, '"PLACEHOLDER_INCLUDE"');

                // Handle !extend tags
                cleaned = cleaned.replace(/!extend\s+[\w\/\.\-]+/g, '"PLACEHOLDER_EXTEND"');

                // Handle !lambda tags (more complex, just replace with placeholder)
                cleaned = cleaned.replace(/!lambda\s*[\|\>]?[\s\S]*?(?=\n\S|\n$)/g, '"PLACEHOLDER_LAMBDA"');

                return cleaned;
            }

            analyzeRawText(yamlText) {
                const lines = yamlText.split('\n');
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();

                    // Skip commented lines (already handled)
                    if (trimmedLine.startsWith('#')) return;

                    // Look for pin assignments in active lines
                    this.findPinsInLine(line, `line ${index + 1}`, false);
                });
            }

            analyzeCommentedPins(yamlText) {
                const lines = yamlText.split('\n');
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('#')) {
                        // Remove the # and analyze the commented line
                        const uncommentedLine = trimmedLine.substring(1).trim();
                        this.findPinsInLine(uncommentedLine, `line ${index + 1} (commented)`, true);
                    }
                });
            }

            traverseObject(obj, path, parentKey = '') {
                if (obj === null || obj === undefined) return;

                if (typeof obj === 'object') {
                    if (Array.isArray(obj)) {
                        obj.forEach((item, index) => {
                            // Try to find a name property for better context
                            let itemName = '';
                            if (item && typeof item === 'object' && item.name) {
                                itemName = ` (${item.name})`;
                            }
                            this.traverseObject(item, `${path}[${index}]${itemName}`, parentKey);
                        });
                    } else {
                        Object.keys(obj).forEach(key => {
                            const newPath = path ? `${path}.${key}` : key;

                            // Check if this key indicates a pin
                            if (this.isPinKey(key)) {
                                this.handlePinValue(obj[key], newPath, key);
                            } else {
                                this.traverseObject(obj[key], newPath, key);
                            }
                        });
                    }
                } else if (typeof obj === 'string') {
                    // Check if the string value might be a pin
                    this.findPinsInLine(obj, path, false);
                }
            }

            isPinKey(key) {
                const pinKeys = [
                    'pin', 'clk_pin', 'mosi_pin', 'miso_pin', 'cs_pin',
                    'sda', 'scl', 'data_pin', 'enable_pin', 'dc_pin',
                    'reset_pin', 'busy_pin', 'cs', 'dc', 'reset',
                    'red', 'green', 'blue', 'white', 'warm_white', 'cold_white'
                ];
                return pinKeys.includes(key.toLowerCase());
            }

            handlePinValue(value, path, pinType = 'pin') {
                if (typeof value === 'string') {
                    if (this.isValidPin(value)) {
                        this.pinUsage.set(value, `${path} (${pinType})`);
                    }
                } else if (typeof value === 'object' && value !== null) {
                    if (value.number && this.isValidPin(value.number)) {
                        const pinInfo = `${value.number}${value.inverted ? ' (inverted)' : ''}${value.mode ? ` (${value.mode})` : ''}`;
                        this.pinUsage.set(value.number, `${path} = ${pinInfo}`);
                    }
                    // Handle other pin object properties
                    Object.keys(value).forEach(key => {
                        if (key === 'number' && this.isValidPin(value[key])) {
                            // Already handled above
                        } else if (this.isValidPin(value[key])) {
                            this.pinUsage.set(value[key], `${path}.${key} (${pinType})`);
                        }
                    });
                } else if (typeof value === 'number') {
                    // Sometimes pins are just numbers
                    const pinStr = value.toString();
                    if (this.isValidPin(pinStr) || this.isValidPin(`GPIO${pinStr}`)) {
                        this.pinUsage.set(pinStr, `${path} (${pinType})`);
                    }
                }
            }

            findPinsInLine(line, path, isCommented) {
                // More comprehensive pin detection patterns
                const pinPatterns = [
                    // Direct pin assignments
                    /(?:pin|clk_pin|mosi_pin|miso_pin|cs_pin|sda|scl|data_pin|enable_pin|dc_pin|reset_pin|busy_pin):\s*([A-Z0-9]+)/gi,
                    // Pin with number
                    /number:\s*([A-Z0-9]+)/gi,
                    // Standalone GPIO/D/A pins
                    /(GPIO\d+)/gi,
                    /([DA]\d+)/gi,
                    // Common ESP pins
                    /(VCC|GND|RST|EN|TX|RX)/gi
                ];

                pinPatterns.forEach(pattern => {
                    const matches = line.matchAll(pattern);
                    for (const match of matches) {
                        const pin = match[1] || match[0];
                        if (this.isValidPin(pin)) {
                            const fullPath = `${path} (${pin})`;
                            if (isCommented) {
                                if (!this.commentedPins.has(pin)) {
                                    this.commentedPins.set(pin, fullPath);
                                }
                            } else {
                                if (!this.pinUsage.has(pin)) {
                                    this.pinUsage.set(pin, fullPath);
                                }
                            }
                        }
                    }
                });
            }

            isValidPin(pin) {
                if (!pin || typeof pin !== 'string') return false;
                const pinStr = pin.toString().toUpperCase();

                // Check against known pins
                if (this.allKnownPins.some(knownPin => knownPin.toUpperCase() === pinStr)) {
                    return true;
                }

                // Check patterns
                const patterns = [
                    /^D\d+$/,           // D0, D1, etc.
                    /^A\d+$/,           // A0, A1, etc.
                    /^GPIO\d+$/,        // GPIO0, GPIO1, etc.
                    /^IO\d+$/,          // IO0, IO1, etc.
                ];

                return patterns.some(pattern => pattern.test(pinStr));
            }

            generateReport() {
                let report = "";

                // Active pins
                report += `🟢 ${this.pinUsage.size} ACTIVE PINS:\n`;
                report += "========================\n";
                if (this.pinUsage.size === 0) {
                    report += "No active pins found.\n";
                } else {
                    const sortedActive = Array.from(this.pinUsage.entries()).sort();
                    sortedActive.forEach(([pin, path]) => {
                        report += `${pin.padEnd(8)} → ${path}\n`;
                    });
                }

                report += "\n";

                // Commented pins
                report += `⚪ ${this.commentedPins.size} COMMENTED/DISABLED PINS:\n`;
                report += "=================================\n";
                if (this.commentedPins.size === 0) {
                    report += "No commented pins found.\n";
                } else {
                    const sortedCommented = Array.from(this.commentedPins.entries()).sort();
                    sortedCommented.forEach(([pin, path]) => {
                        report += `${pin.padEnd(8)} → ${path}\n`;
                    });
                }

                return report;
            }
        }

        // Initialize the analyzer
        const analyzer = new ESPHomePinAnalyzer();

        // Set up event listeners
        document.addEventListener('DOMContentLoaded', function () {
            const yamlInput = document.getElementById('yamlInput');
            const analysisOutput = document.getElementById('analysisOutput');

            function performAnalysis() {
                const yamlContent = yamlInput.value.trim();
                if (yamlContent) {
                    const analysis = analyzer.analyzeYAML(yamlContent);
                    analysisOutput.value = analysis;
                } else {
                    analysisOutput.value = 'Please paste your ESPHome YAML configuration above.';
                }
            }

            // Analyze on input change (with debounce)
            let timeout;
            yamlInput.addEventListener('input', function () {
                clearTimeout(timeout);
                timeout = setTimeout(performAnalysis, 500);
            });

            // Analyze on paste
            yamlInput.addEventListener('paste', function () {
                setTimeout(performAnalysis, 100);
            });
        });
    </script>
</body>

</html>
